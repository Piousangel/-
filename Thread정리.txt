extends Thread or implements Runnable

Runnable r = new Thread~();
Thread t2 = new Tread(r);

start() 메서드 호출 후에 쓰레드 실행 start했다고 무조건 실행되는것 아니고 start먼저했다고 먼저 실행되는것도 아님
OS에 스케쥴러가 실행 순서를 결정함 쓰레드는 OS에 종속적임

Thread -> getName();
Runnable -> Thread.currentThread().getName();

메인쓰레드란 메인메서드의 코드를 수행하는 쓰레드
메인메서드의 쓰레드를 사용자쓰레드라고 하고 보조 역할을 하는 보조 쓰레드인 데몬 쓰레드가 있음.

프로그램은 실행중인 사용자 쓰레드가 하나도 없을 때 종료된다.
데몬 쓰레드가 있어도 사용자 쓰레드가 없으면 프로그램은 종료됨

join() 메서드 사용시 메인메서드가 join() 메서드 종료시 까지 기다림
try, catch구문 사용

멀티 쓰레드 프로그램일 때 사용자 쓰레드가 많아질 수 있음

쓰레드의 I/O 블라킹

싱글쓰레드의 경우 예를 들어 입출력 blocking구간에서 사용자로부터 입력을 기다리는동안 아무것도 할 수 없지만
멀티쓰레드의 경우 다른 쓰레드가 작업하므로 효율적으로 동작함

쓰레드의 우선순위(priority of thread)
- 작업의 중요도에 따라 쓰레드의 우선순위를 다르게 하여 특정 쓰레드가 더 많은 작업 시간을 갖게 함
- 자바에서는 쓰레드의 우선순위를 1~10까지 보유할 수 있게 함
void setPriority(int new Priority)
int get Priority()
public static final int MAX_PRIORITY = 10;
public static final int MIN_PRIORITY = 1;
기본적으로 보통우선순위 5로 만들어지게 되있음
우선순위가 높으면 많이 선점할 수 있지만 무조건 먼저 끝나거나 무조건적인건 아님.

쓰레드 그룹
모든 쓰레드는 반드시 하나의 쓰레드 그룹에 포함되어 있어야합니다.
쓰레드그룹을 지정하지 않고 생성한 쓰레드는 메인 쓰레드 그룹
ThreadGroup getThreadGroup() 자신이 속한 쓰레드 그룹 반환
void uncaughtException(Thread t, Throwable e)
-> 처리되지 않은 예외에 의해 쓰레드 그룹의 쓰레드가 실행이 종료되었을 때, JVM에 의해 이 메서드가 자동적으로 호출됨니다

OS스케쥴러가 알아서...
쓰레다는 따로 지정하지 않으면 메인쓰레드 그룹에 속하고 부모 그룹과 우선순위를 상속받음!

데몬쓰레드

 




다중 스레드 기법을 사용했을 때 단일 스레드 기법을 사용했을 때 보다 성능이 좋지 않은 프로그래밍 사례 2가지
-> 다중스레드에서는 각각의 스레드 중 어떤 스레드가 먼제 시작될지 모른다.

ex1) 공유되는 변수 i의 값을 1씩 증가시키는 프로그램의 경우 순차적으로 값이 증가되어야 하는데 
한번에 2씩 증가될 수도 있는 등 순차적으로 실행되는 것을 보장할 수 없다

ex2) C shell 같은 쉘프로그램(실행내용을 계속 모니터해야하는 프로그램들)일때 제대로 기능을 할 수 없다.

========================================================================================
========================================================================================

단일 처리기 시스템에서의 프로그래밍을 고려하자. 다중 커널 스레드를 사용하여 다중스레드 프로그램을 만들었을 때
이 프로그램의 성능이 단일 스레드만 사용하는 프로그램에 비해 더 나은 성능을 보이는 경우는 언제인가?

-> 단일 처리기 시스템이기 때문에 비록 연산속도의 향상은 얻을 수 없지만 사용자 반응 시간이라는 측면에서 볼 때는
성능 향상을 얻을 수 있다. 여러 스레드가 시스템에 적재되어 있고, 각각의 스레디는 사용자의 반응에 의해
활성화되도록 프로그램을 구성한다면 사용자의 다양한 반응에 즉각적으로 반응할 수 있기 때문에 단일 스레드만 사용하는
프로그램에 비해 좀 더 나은 성능을 가질 수 있다!

========================================================================================
========================================================================================

다음 중 다중 스레드 프로세스의 스레드 사이에 공유되는 프로그램 상태는 무엇인가?  힙, 코드(전역변수), 데이터
a. 레지스터 값들
b. 힙 메모리
c. 전역변수들
d. 스택 메모리

-> 다중 스레드 프로세서의 스레드 사이에 공유되는 프로그램 상태는 힙메모라와 전역변수 들이다
레지스터 값들과 스택 메모리는 프로세서 내에 다른 실행 흐름을 가지기 위해서 스레드당 개인적으로
들고있는 값들이고, 힙 메모리와 전역변수와 같이 공유되어지면서 한 프로세서 안에서 여려일을 빠르게 할 수 있다

========================================================================================
========================================================================================

다수의 사용자 수준 스레드를 사용하는 다중 스레드 해결책이 단일 처리기 시스템보다 다중 처리기 시스템에서
더 나은 성능을 보일 수 있는가? 답변해보세요!

-> 더 나은 성능을 보일 수 있다고 생각합니다. 하나의 코어에는 한번에 오직 하나의 쓰레드만 실행시킬 수 있는데
다수의 사용자 수준 스레드가 잘 구성되어 있다고 하더라도 단일 처리기 시스템은 결국 처리기가 하나이기 때문에
순차적으로 진행 될 수 밖에 없다. 그러나 복수의 처리기를 가지고 있는 다중 처리기 시스템은 각각의 처리기에게
사용자 쓰레드를 분배할 수 있기 때문에 단일 처리기 시스템 보다 빠르게 처리할 수 있다.

========================================================================================
========================================================================================

Google 의 Chrome 브라우저에 대해서 논의할 때 새로운 웹사이트마다 개별 프로세스에서 연다는 것을 아는데 
만일 새로운 웹사이트를 프로세스 대신에 개별 스레드에서 열었다면 같은 이득을 얻을 수 있을까요?

-> 개별 스레드에서 연다면 하나의 웹사이트에서 오류가 발생해서 종료해야 할 상황이 오면
다른 모든 웹사이트도 종료해야하기 때문에 같은 이득을 얻을 수 없습니당.(개별 프로세스인 경우 오류가 난 해당 웹사이트만 종료시킬 수 있습니다.)


========================================================================================
========================================================================================

데이터 병렬성 : 전체 데이터를 가능한 동일한 크기로 나누어 각 프로세스에 할당하고 프로세스는 할당 받은 데이터에 대해
동일한 일련의 계산을 수행하는 것으로 도메인 분해라고도 한다.

테스크 병렬성 : 각 프로세스가 서로 다른 계산을 할당 받아 수행하는 것으로 기능적 분해라고도 한다.
각 프로세스는 동일한 데이터 또는 서로 다른 데이터를 가지고 서로 다른 함수의 계산을 수행하게 된다.
ex) 3개의 쓰레드를 생성한 후 하나는 숫자의 평균, 하나의 최댓값, 하나는 최솟값을 구한다
    이렇게 되면 테스크 병렬성이다.

========================================================================================
========================================================================================

부모 프로세스가 fork하면 자식 프로세스가 생성됨. 부모 프로세스가 fork를 2번 실행하면 부모 포함 총 3개의 프로세스가 생성됨
자식 프로세스가 fork를 한번 실행한후 다시 생성된 프로세스가 fork를 더 실행하면 총 3개
더하면 총 7개
리눅스(Linux)는 프로세스와 스레드를 구별하지 않는다.

========================================================================================
========================================================================================

Pthreads API

#include <pthread.h>
#include <stdio.h>

int value = 0; // 전역변수선언
void *runner(void *param);

int main(){
    int pid;
    pthread_t tid;
    pthread_attr_t attr;

    pid = fork();

    if( pid == 0){
        pthread_attr_init(&attr);
        pthread_create(&tid, &attr, runner, NULL);
        pthread_join(tid, NULL);

        printf("CHILD : value = %d", value);
    }
    else if(pid >0){
        wait(NULL);
        printf("PARENT : value = %d", value);
    }
}

void *runner(void *param){
    value = 5;
    pthread_exit(0);
}

출력 결과 :   CHILD : value = 5;
            PARENT : value = 0;

 설명 : fork() 호출로 자식 프로세스 생성됨. 자식 프로세스는
 pthread를 이용해서 쓰레드를 생성하고 쓰레드 안에서 value를 5로 초기화 함
 쓰레드는 프로세스 안에 존재하는 것이고 value는 전역 변수이기때문에
 자식 프로세스의 출력에는 5라는 값이 출력됨
 그러나 부모 프로세스의 value는 자식프로세스의 value와 다른 메모리에 있는
 변수이기 때문에 자식프로세스의 쓰레드에 영향을 받지 않았고 0을 출력한다.

========================================================================================
========================================================================================

스케쥴러는 커널스레드에 먼저 맵핑함 커널쓰레드 -> 유저쓰레드 순
parlism? 병렬성 이건 아니고 동시 수행성
유저가 인식하지 못할 정도로 빠르게 문맥 교환(context swiching)을 수행하면서
사용저는 프로그램이나 기능이 동시에 수행되는 것 처럼 느끼기 때문에
병렬성을 아니지만 동시 수행성을 가지는 것이 가능함.

========================================================================================
========================================================================================

스레드 취소 사용불가능 상태로 지정하기 위한 함수 호출과 취소 사용 가능 상태로 지정하기 위한
함수 호출과 취소 사용 가능 상태로 지정하기 위한 함수 호출 상태 사이에 수행하기 적합한
두 연산의 예가 뭐가 있을까

-> 뮤텍스나 세마포어와 같은 상호배제 기법에서 공유 메모리에 대한 접근 권한을 획득한
스레드는 반드시 접근 권한을 반환하는 작업을 마친 후에 종료되어야 하기 때문에
코드 사이에 수행하는 것이 필요하다.

-> 어떤 쓰레드가 필요해 의해 다른 쓰레드를 생성하였거나 가비지 컬렉터가 존재하지 않는
환경에서 자신의 스택에 동적으로 할당받은 자원이 존해한다면 해당 쓰레드는 반드시
생성한 쓰레드를 종료하고, 동적으로 할당받은 자원을 반환해야 합니다. 따라서
쓰레드를 생성하였거나 적으로 자원을 할당받은 쓰레드는 코드 사이에 수행되는 것이 적합힙니다.
