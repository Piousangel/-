request.getParameterNames().asIterator()
        .forEachRemaining(paraName -> System.out.println(paraName + "=" + request.getParameter(paraName)));

get방식에서 단일조회 request.getParameter() / 중복 조회 request.getParameterValues()

Post방식  get,post -> request.getParmeter()로 다 받아올수있음
posst html form 형식으로 데이터를 전달하면 http메세지 바디에 해당 데이터를 포함해서 보내기 때문에
바디에 포함된 데이터가 어떤 형식인지 content-type을 꼭 지정해야한다. 
content-type : application~으로 시작 그래서 아마 startsWith 어플리케이션하는게 있던걸로 기억하는데
메세지 바디에 쿼리 파라미터 형식으로 데이터 전달

API 메세지 바디 - 단순 텍스트
HTTP message body에 데이터를 직접 담아서 요청
http api에서 주로 사용, json, xml..
데이터형식은 주로 json , // Post, put, patch 3가지 Http 메서드 사용

ServeltInputStream inputStream = request.getInputStream();  //바이트코드로변환
String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); //utf-8명시해줘야함
response.getWriter().wirte("ok");

HTTP API에서 Json형식으로 데이터를 전달하는 방법
처음 Json형식으로 파싱할수있게 getter, setter 만듬
Lombok에 @Getter, @Setter사용
contentType = json

jackson 라이브러리 사용

private ObjectMapper objectMapper = new ObjectMapper();
HelloData helloData = objectMapper.readValue(messageBody, HelloData.class);
helloData.getUsername();
helooData.getAge();

HttpServletResponse
200 400 500 등 Http응답코드 지정가능
헤더 생성
바디 생성
편의 기능 제공 Content-type헤더, 쿠키, Redirect 등
 status line
 response.setStatus(HttpServletResponse.SC_OK)); 기본성공 200 SC_OK
  
response-headers
response.setHeader("Content-Type", text/plain)
response.setHeader("Cache-Control", "no-cahe, no-store, must-revalidate"); //캐시제거
response.setHeader("Pragma", no-cache");  //과거캐시까지 제거

response.setContentType("text/plain");
response.setCharacterEncoding("utf-8");

Cookie cooke = new Cookie("myCookie", "good"); 
cookie.setMaxAge(600);
response.addCookie(cookie);

//response.setStatus(HttpServletResponse.SC_FOUND);
//response.setHeader("Location", "/basic/hello-form.html");
response.sendRedirect("/basic/hello-form.html");

HTTP응답으로 HTML을 반환할 때는 contentType을 text/html로 지정해야한다.

ObjectMapper objectMapper = new objectmapper();
response.setContentType("application/json");
response.setCharacterEncoding("utf-8");
리스폰스하기!!!!!!
HelloData helloData = new HellowData();
helloData.setUsername("kim");
helloData.setAge(20);
String result = objectMapper.writeValueAsString();
response.getWriter().wirte(result);


@AfterEach -> clearStore() , @Test
Assertions.assertThat().isEqualsTo()
테스트의 순서가 보장이 안되기때문에 AtferEach clearStore꼭해줘야함

동적으로 뿌려줄때 PrintWriter w = response.getWriter();
Servlet에서
w.write() ~
for(Member member : members){
        "+member.getId()+"
        "+member.getUsername()+"
        "+member.getAge()+"
}
이런식으로 포문 돌리면서 동적으로 뿌려줌
JSP 템플릿 엔진을 사용하면 
<%@ page contentType="text/html; charset=UTF-8" language="java" %> 로시작
<%= ~로 자바코드찍으면 됨%> 이건 출력
<% ~~  %> 이건 입력

서블릿과 JSP한계
하나의 서블릿, JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되면 많은 역할을 하게되고, 유지보수가 어렵다.
HTML , java 코드가 섞여 지저분하고 복잡   -> MVC패턴으로 아예 영역을 나눔

컨트롤러 모델 뷰 인데 컨트롤러에 비즈니스 로직을 둘수도 있지만 이렇게 되면 너무 많은 역할을 컨트롤러가
하게 되므로 일반적으로 비즈니스 로직은 서비스라는 계층을 별로도 만들어 처리한다.
컨트롤러는 비즈니스 로직이 있는 서비스를 호출하는 역할 담당

일딴은 request.setAttribute() - 컨트롤러, request.getAttribute() - 뷰 로 데이터 보관, 조회 할려고함
컨트롤러 -> 뷰 request.getRequestDispatcher() 
dispatcher.forward(request, dispatcher)  => 리다이렉트 개념아님
action = "/save"  = 절대경로 , action = "save" = 상대경로

WEB-INF내부 파일들은 외부에서 그냥 호출할 수 없고 controller를 거쳐 forward등으로 호출한다.

%{member.username} = <%=(Member)request.getAttribute("member)).getUsername()%>
지금은 거의 안쓰지만 JSTL가져와서 JSP좀더 깔끔하게 만들 수 있음
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<c: forEach var="item" items="${members}">

하지만 포워드, Viewpath중복, 사용하지 않는 코드 , 공통처리가 어려움

프론트 컨트롤러 패턴

프론트 컨트롤러 도입 이전 -> 공통로직이 있어도 controller A, B, C가 가지고있어야했지만
프론트 컨트롤러(서블릿) 도입 후 공통로직은 처음 프론트 컨트롤러에서 처리하고 컨트롤러로 뿌려줌
즉, 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨

urlPatterns = "/front-controller/v1/*"

뷰 리졸버(viewResolver)를 통해 컨트롤러는 뷰의 논리이름을 반환하고 실제 물리 위치의 이름은 프론트 컨트롤러에서 뷰리졸버를 통해 단순화 하자

유연한 컨트롤러 - 어뎁터패턴

어뎁터 확인후 처리가능 -> true반환 처리 안되면 -> false반환
instanceOf사용

front controller -> dispatcher servlet
MVC 패턴 여기서 시작