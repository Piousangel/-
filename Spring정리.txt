request.getParameterNames().asIterator()
        .forEachRemaining(paraName -> System.out.println(paraName + "=" + request.getParameter(paraName)));

get방식에서 단일조회 request.getParameter() / 중복 조회 request.getParameterValues()

Post방식  get,post -> request.getParmeter()로 다 받아올수있음
posst html form 형식으로 데이터를 전달하면 http메세지 바디에 해당 데이터를 포함해서 보내기 때문에
바디에 포함된 데이터가 어떤 형식인지 content-type을 꼭 지정해야한다. 
content-type : application~으로 시작 그래서 아마 startsWith 어플리케이션하는게 있던걸로 기억하는데
메세지 바디에 쿼리 파라미터 형식으로 데이터 전달

API 메세지 바디 - 단순 텍스트
HTTP message body에 데이터를 직접 담아서 요청
http api에서 주로 사용, json, xml..
데이터형식은 주로 json , // Post, put, patch 3가지 Http 메서드 사용

ServeltInputStream inputStream = request.getInputStream();  //바이트코드로변환
String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); //utf-8명시해줘야함
response.getWriter().wirte("ok");

HTTP API에서 Json형식으로 데이터를 전달하는 방법
처음 Json형식으로 파싱할수있게 getter, setter 만듬
Lombok에 @Getter, @Setter사용
contentType = json

jackson 라이브러리 사용

private ObjectMapper objectMapper = new ObjectMapper();
HelloData helloData = objectMapper.readValue(messageBody, HelloData.class);
helloData.getUsername();
helooData.getAge();

HttpServletResponse
200 400 500 등 Http응답코드 지정가능
헤더 생성
바디 생성
편의 기능 제공 Content-type헤더, 쿠키, Redirect 등
 status line
 response.setStatus(HttpServletResponse.SC_OK)); 기본성공 200 SC_OK
  
response-headers
response.setHeader("Content-Type", text/plain)
response.setHeader("Cache-Control", "no-cahe, no-store, must-revalidate"); //캐시제거
response.setHeader("Pragma", no-cache");  //과거캐시까지 제거

response.setContentType("text/plain");
response.setCharacterEncoding("utf-8");

Cookie cooke = new Cookie("myCookie", "good"); 
cookie.setMaxAge(600);
response.addCookie(cookie);

//response.setStatus(HttpServletResponse.SC_FOUND);
//response.setHeader("Location", "/basic/hello-form.html");
response.sendRedirect("/basic/hello-form.html");

HTTP응답으로 HTML을 반환할 때는 contentType을 text/html로 지정해야한다.

ObjectMapper objectMapper = new objectmapper();
response.setContentType("application/json");
response.setCharacterEncoding("utf-8");
리스폰스하기!!!!!!
HelloData helloData = new HellowData();
helloData.setUsername("kim");
helloData.setAge(20);
String result = objectMapper.writeValueAsString();
response.getWriter().wirte(result);


@AfterEach -> clearStore() , @Test
Assertions.assertThat().isEqualsTo()
테스트의 순서가 보장이 안되기때문에 AtferEach clearStore꼭해줘야함

동적으로 뿌려줄때 PrintWriter w = response.getWriter();
Servlet에서
w.write() ~
for(Member member : members){
        "+member.getId()+"
        "+member.getUsername()+"
        "+member.getAge()+"
}
이런식으로 포문 돌리면서 동적으로 뿌려줌
JSP 템플릿 엔진을 사용하면 
<%@ page contentType="text/html; charset=UTF-8" language="java" %> 로시작
<%= ~로 자바코드찍으면 됨%> 이건 출력
<% ~~  %> 이건 입력

서블릿과 JSP한계
하나의 서블릿, JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되면 많은 역할을 하게되고, 유지보수가 어렵다.
HTML , java 코드가 섞여 지저분하고 복잡   -> MVC패턴으로 아예 영역을 나눔

컨트롤러 모델 뷰 인데 컨트롤러에 비즈니스 로직을 둘수도 있지만 이렇게 되면 너무 많은 역할을 컨트롤러가
하게 되므로 일반적으로 비즈니스 로직은 서비스라는 계층을 별로도 만들어 처리한다.
컨트롤러는 비즈니스 로직이 있는 서비스를 호출하는 역할 담당