request.getParameterNames().asIterator()
        .forEachRemaining(paraName -> System.out.println(paraName + "=" + request.getParameter(paraName)));

get방식에서 단일조회 request.getParameter() / 중복 조회 request.getParameterValues()

Post방식  get,post -> request.getParmeter()로 다 받아올수있음
posst html form 형식으로 데이터를 전달하면 http메세지 바디에 해당 데이터를 포함해서 보내기 때문에
바디에 포함된 데이터가 어떤 형식인지 content-type을 꼭 지정해야한다. 
content-type : application~으로 시작 그래서 아마 startsWith 어플리케이션하는게 있던걸로 기억하는데
메세지 바디에 쿼리 파라미터 형식으로 데이터 전달

API 메세지 바디 - 단순 텍스트
HTTP message body에 데이터를 직접 담아서 요청
http api에서 주로 사용, json, xml..
데이터형식은 주로 json , // Post, put, patch 3가지 Http 메서드 사용

ServeltInputStream inputStream = request.getInputStream();  //바이트코드로변환
String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); //utf-8명시해줘야함
response.getWriter().wirte("ok");

HTTP API에서 Json형식으로 데이터를 전달하는 방법
처음 Json형식으로 파싱할수있게 getter, setter 만듬
Lombok에 @Getter, @Setter사용
contentType = json

jackson 라이브러리 사용

private ObjectMapper objectMapper = new ObjectMapper();
HelloData helloData = objectMapper.readValue(messageBody, HelloData.class);
helloData.getUsername();
helooData.getAge();

HttpServletResponse
200 400 500 등 Http응답코드 지정가능
헤더 생성
바디 생성
편의 기능 제공 Content-type헤더, 쿠키, Redirect 등
 status line
 response.setStatus(HttpServletResponse.SC_OK)); 기본성공 200 SC_OK
  
response-headers
response.setHeader("Content-Type", text/plain)
response.setHeader("Cache-Control", "no-cahe, no-store, must-revalidate"); //캐시제거
response.setHeader("Pragma", no-cache");  //과거캐시까지 제거

response.setContentType("text/plain");
response.setCharacterEncoding("utf-8");

Cookie cooke = new Cookie("myCookie", "good"); 
cookie.setMaxAge(600);
response.addCookie(cookie);

//response.setStatus(HttpServletResponse.SC_FOUND);
//response.setHeader("Location", "/basic/hello-form.html");
response.sendRedirect("/basic/hello-form.html");

HTTP응답으로 HTML을 반환할 때는 contentType을 text/html로 지정해야한다.

ObjectMapper objectMapper = new objectmapper();
response.setContentType("application/json");
response.setCharacterEncoding("utf-8");
리스폰스하기!!!!!!
HelloData helloData = new HellowData();
helloData.setUsername("kim");
helloData.setAge(20);
String result = objectMapper.writeValueAsString();
response.getWriter().wirte(result);


@AfterEach -> clearStore() , @Test
Assertions.assertThat().isEqualsTo()
테스트의 순서가 보장이 안되기때문에 AtferEach clearStore꼭해줘야함

동적으로 뿌려줄때 PrintWriter w = response.getWriter();
Servlet에서
w.write() ~
for(Member member : members){
        "+member.getId()+"
        "+member.getUsername()+"
        "+member.getAge()+"
}
이런식으로 포문 돌리면서 동적으로 뿌려줌
JSP 템플릿 엔진을 사용하면 
<%@ page contentType="text/html; charset=UTF-8" language="java" %> 로시작
<%= ~로 자바코드찍으면 됨%> 이건 출력
<% ~~  %> 이건 입력

서블릿과 JSP한계
하나의 서블릿, JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되면 많은 역할을 하게되고, 유지보수가 어렵다.
HTML , java 코드가 섞여 지저분하고 복잡   -> MVC패턴으로 아예 영역을 나눔

컨트롤러 모델 뷰 인데 컨트롤러에 비즈니스 로직을 둘수도 있지만 이렇게 되면 너무 많은 역할을 컨트롤러가
하게 되므로 일반적으로 비즈니스 로직은 서비스라는 계층을 별로도 만들어 처리한다.
컨트롤러는 비즈니스 로직이 있는 서비스를 호출하는 역할 담당

일딴은 request.setAttribute() - 컨트롤러, request.getAttribute() - 뷰 로 데이터 보관, 조회 할려고함
컨트롤러 -> 뷰 request.getRequestDispatcher() 
dispatcher.forward(request, dispatcher)  => 리다이렉트 개념아님
action = "/save"  = 절대경로 , action = "save" = 상대경로

WEB-INF내부 파일들은 외부에서 그냥 호출할 수 없고 controller를 거쳐 forward등으로 호출한다.

%{member.username} = <%=(Member)request.getAttribute("member)).getUsername()%>
지금은 거의 안쓰지만 JSTL가져와서 JSP좀더 깔끔하게 만들 수 있음
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<c: forEach var="item" items="${members}">

하지만 포워드, Viewpath중복, 사용하지 않는 코드 , 공통처리가 어려움

프론트 컨트롤러 패턴

프론트 컨트롤러 도입 이전 -> 공통로직이 있어도 controller A, B, C가 가지고있어야했지만
프론트 컨트롤러(서블릿) 도입 후 공통로직은 처음 프론트 컨트롤러에서 처리하고 컨트롤러로 뿌려줌
즉, 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨

urlPatterns = "/front-controller/v1/*"

뷰 리졸버(viewResolver)를 통해 컨트롤러는 뷰의 논리이름을 반환하고 실제 물리 위치의 이름은 프론트 컨트롤러에서 뷰리졸버를 통해 단순화 하자

유연한 컨트롤러 - 어뎁터패턴

어뎁터 확인후 처리가능 -> true반환 처리 안되면 -> false반환
instanceOf사용

front controller -> dispatcher servlet
MVC 패턴 여기서 시작

HandlerMapping
0 = RequestMappingHandlerMapping : 어노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
1 = BeanNameUrlHandlerMapping : 스프링 빈의 이름으로 핸들러를 찾는다

HandlerAdapter
0 = RequestMappingHandlerAdapter : 어노테이션 기반의 컨트롤러인 @RequestMapping 
1 = HttpRequestHandlerAdpter : httpRequestHandler 처리
2 = SimpleControllerHandlerAdapter : Controller 인터페이스(어노테이션 x, 과거에 사용) 처리

HandlerMapping = BeanNameUrlHandlerMapping
HandlerAdapter = SimpleControllerHandlerAdapter

RequestMappingHandlerMapping , RequestMappingHandlerMapping
@RequestMapping!!!!!!! 실무에서 99퍼센트 사용

application.properties 에
spring.mvc.view.prefix
spring.mvc.view.suffix 넣어줌
뷰 리졸버 - InternalResourceViewResolver가 프로퍼티의 preifx, suffix가져와서 등록함

스프링 부트가 자동 등록하는 뷰 리졸버
1 = BeanNameViewResolver : 빈 이름으로 뷰를 찾아서 반환
2 = InternalResourceViewResolver : JSP를 처리할 수 있는 뷰를 

RequestMappingHandlerMapping은 스프링 빈 중에서 @RequestMapping 또는 @Controller가
클래스 레벨이 붙어있는 경우에 매핑 정보를 인식한다.

@RequestParam 요청파라미터를 처리하는 어노테이션
즉, @RequestParam("username") = request.getParameter("username");

@RequestMapping(value = "/new-form" , method = RequestMethod.GET)
-> method = RequestMethod.GET , RequestMethod.POST

이게 개선된게 @GetMapping() , @PostMapping()

로깅!!!!!
실무에서는 System.out.println()을 쓰지않음
로깅 라이브러리 사용
스프링 부트 라이브러리안에 로깅라이브러리(spring-boot-starter-logging)이 함께 포함됨
SLF4J Logback
통합된 인터페이스로 제공하는 것 -> SLF4J
실무에서는 스프링 부트가 기본적으로 제공하는 Logback을 대부분 사용함

로그 선언
private Logger log = LoggerFactory.getLogger(getClass());
private static final Logger log = LoggerFactory.getLogger(Xxx.class)
@Slf4j : 롬복 사용 가능

로그 호출
log.info("hello") = System.out.println("hello")
시스템 콜솔로 직접 출력하는 것 보다 실무에서는 log.info()사용

그냥 컨트롤러는 view로 인식하고 뷰네임 반환 하는데
@RestController는 리턴값이 스트링이면 걍 스트링을 반환함
이게 먼말이냐 HTTP 메세지 바디에 바로 입력한다는 말임

aplication.properties에서
logging.level.hellow.springmvc = 로깅 레벨 정함
위험도? 
log.trace();
log.debug();
log.info();
log.warn();
log.error(); 순서 로그레벨

운영서버에 System.out.println()으로 다 남기면 어지럽긴하겠다
개발서버에서는 debug부터
운영서버는 info부터 한다고 합니당

롬복에서
@Slf4j 넣으면 private final Logger log = LoggerFactory.getLogger(getClass());
없어도 로깅가능

로그 사용시 장점
- 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다
- 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영서버에서는 출력하지 않는 등
  로그를 상황에 맞게 조절할 수 있다.
- 시스템 아웃 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에
  남길 수 있다. 특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다
- 성능도 일반 System.out보다 좋다. 내부 버퍼링, 멀티 쓰레드 등등 그래서 실무에서는 꼭 로그를 사용해야 한다.

PathVariable(경로변수 사용)
ex) @GetMapping("/mapping/{userId}")
public String mappingPath(@PathVariable("userId") String data){
        ~~
}

@RequestMapping를 통해 리소스를 계층으로 식별하면 개발자들이 보기 좋다..
URL하나로 묶어서 리케스트매핑에 넣기..

클래스 위에 RestController 넣어도 되고 메서드 위에 @ResponseBody넣어도 messageBody에 넣어주는 역할을 함니당
